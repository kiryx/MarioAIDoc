\chapter{Wstêp teoretyczny}

\section{Historia sztucznej inteligencji.}
\begin{par}
Na pocz¹tku lat 40 matematycy i in¿ynierowie z oœrodków badawczych zaczêli zastanawiaæ siê nad mo¿liwoœci¹ stworzenia sztucznego mózgu.
Pierwsze formalne centrum badawcze pracuj¹ce nad zagadnieniem sztucznej inteligencji zosta³o powo³ane do ¿ycia w 1956 roku w Dartmouth College, 16 lat po wynalezieniu pierwszego programowalnego komputera.
Pocz¹tkowo nazywane przedsiêwziêciem stworzenia pierwszego ``Elektronicznego mózgu'' zosta³o powa¿nie potraktowane przez ówczesnych naukowców, i tworzy³o dobre perspektywy dla ekonomistów i bankierów.
Wielu badaczy zapowiedzia³o stworzenie maszyn dorównuj¹cych inteligencj¹ ludziom w niespe³na kilka dekad.
Specjalnie na ten cel rz¹d amerykañski oraz brytyjski przeznaczy³y bud¿et rzêdu milionów dolarów.
\end{par}
\begin{par}
Pierwsze prace nad sztuczn¹ inteligencj¹ skupia³y siê na odwzorowaniu realnej pracy ludzkiego mózgu - sieci neuronów.
Naukowcy tacy jak Norbert Wiener, Claude Shannon oraz Alan Turing opracowali pierwsze pomys³y stworzenia elektronicznego mózgu.
Powsta³o pojêcie sieci neuronowych, mocno póŸniej rozwijane m.in. przez Marvina Minskiego w jego pracach przez nastêpne 50 lat.
Pierwsze programy skupiaj¹ce siê na sztucznej inteligencji w grach powsta³y na pocz¹tku lat 50. Christopher Strachey by³ autorem pierwszego programu graj¹cego w Warcaby.
Pierwszy program szachowy zosta³ napisany przez Dietricha Prinza.
W tym samym okresie Alan Turing opublikowa³ pierwsze prace dotycz¹ce mo¿liwoœci utworzenia maszyny dysponuj¹cej ludzk¹ inteligencj¹.
Zdefiniowa³ test pozwalaj¹cy to zmierzyæ, nazywany potem Testem Turinga.
\end{par}
\begin{par}
W koñcu po wielu latach sta³o siê oczywiste i¿ symulacja nawet najprostszych mechanizmów myœlowych jest niezwykle trudna w realizacji, a nawet najszybsze ówczesne komputery nie by³y w stanie wygraæ z cz³owiekiem w partii szachów. 
Ostatecznie dziedzinie sztucznej inteligencji odebrano nieco wiarygodnoœci, a wczeœniej zapowiadane maszyny przerastaj¹ce inteligencj¹ ludzi, trafi³y z powrotem na pó³ki science-fiction. W roku 1973, znaczna czêœæ funduszy przeznaczonych na rozwój sztucznej inteligencji zosta³a wstrzymana przez amerykañski i brytyjski rz¹d.
Niemniej prace nad sztuczn¹ inteligencj¹ trwaj¹ do dziœ, aczkolwiek s¹ bardziej uszczegó³owione w naturze problemów których dotycz¹.
\end{par}


\section{Sztuczna w dzisiejszych zastosowaniach.}
\begin{par}
Oprócz realizacji zadañ w dziedzinie kategoryzacji danych, oraz rozpoznawaniu mowy lub obrazu, spora czêœæ badañ skupia siê na realizacji systemów podejmuj¹cych decyzje w œciœle okreœlonym œrodowisku gry.
Pozornie s³u¿¹ one jedynie dostarczaniu rozrywki w szeroko popularnych grach komputerowych, szybko mo¿na siê przekonaæ i¿ wiele takich projektów jest póŸniej podstaw¹ do stworzenia bardziej praktycznych systemów. Zmieniaj¹c jedynie definicjê œrodowiska okazuje siê i¿ mo¿na te same strategie zastosowaæ np. w grze na gie³dzie.
Pojedynek Garriego Kasparowa z programem szachowym Deep Blue przeszed³ ju¿ na sta³e do historii jako pierwsze starcie cz³owieka z maszyn¹ w dziedzinie intelektu. 
Innym, doœæ nowym przyk³adem mo¿e byæ klaster komputerów Watson \cite{watson}, który przez kilka tygodni konkurowa³ z czo³ówk¹ graczy teleturnieju Jeopardy, popularnym w USA od 1964 roku.
Obydwa projekty pokona³y swoich ludzkich przeciwników, podnosz¹c tym samym nieco nadszarpniêty wizerunek sztucznej inteligencji.
Wiele wspó³czesnych zastosowañ sztucznej inteligencji zyska³o du¿¹ popularnoœæ dziêki globalnej sieci internet.
Prym wiedzie tutaj firma Google, pocz¹tkowo znana jedynie jako twórca najpopularniejszej i najdok³adniejszej wyszukiwarki, rozbudowuje bazê swoich aplikacji o translatory,
aplikacje do nawigacji map, czy program graficzny Picasa potrafi¹cy zidentyfikowaæ na zdjêciu ludzk¹ twarz.
Wiêkszoœæ wyszukiwarek internetowych wykorzystuje ró¿nego rodzaju systemu wspomagaj¹ce w wyszukiwaniu informacji na temat konkretnej frazy.
Aktywna lista podpowiedzi wyœwietlaj¹ca siê po wpisaniu pocz¹tku popularnej frazy sta³a siê wrêcz standardem w projektowaniu wyszukiwarki.
Wyszukiwarka coraz czêœciej poprawia b³êdy ortograficzne lub niepoprawnie przeliterowane wyrazy zwi¹zane np. z bliskim s¹siedztwem liter na klawiaturze.
Innym ciekawym zastosowaniem jest t³umaczenie tekstu z dowolnego jêzyka na inny.
Nie dzia³a to na zasadzie bazy danych przechowuj¹cej odpowiedniki s³ów w ka¿dym z jêzyków, lecz wykorzystuje metodê ``uczenia siê'' ca³ych wyra¿eñ b¹dŸ zwrotów które s¹ równorzêdne w obu jêzykach, 
dziêki czemu zyskujemy doœæ precyzyjne t³umaczenie nawet jeœli chodzi o nazwy w³asne, akronimy, odmianê oraz sk³adniê, np.: Przy t³umaczeniu z angielskiego na polski frazy ``United States of America'' uzyskujemy ``Stany Zjednoczone'', natomiast ``in UK'' t³umaczone na jêzyk polski poprawnie daje zwrot ``w Wielkiej Brytanii''.
W pierwszym przyk³adzie naiwna metoda nie ominê³aby s³owa ``America'' oraz prawdopodobnie nie zachowa³aby szyku s³ów. Wynikiem mog³oby byæ wówczas ``Zjednoczone Stany Ameryki''.
Innym ciekawym zastosowaniem mo¿e byæ aplikacja Wolfram Alpha \cite{wolfram} stworzona przez Stephena Wolframa - twórcê oprogramowania ``Mathematica''.
Podobnie jak wyszukiwarka Google, opiera ona swoje wyniki na frazach wpisywanych do okna wyszukiwarki przez u¿ytkownika, jednak jest ona skupiona g³ównie na przetwarzaniu danych matematycznych.
Potrafi interpretowaæ wzory wpisane przez u¿ytkownika, wyœwietliæ wykres w przestrzeni oraz dostarczyæ wielu dodatkowych informacji np. znaleŸæ pierwiastki rzeczywiste.
O ile sztuczna inteligencja w œwietle dzisiejszego dostêpu ogromu danych do przetwarzania stwarza du¿y potencja³ na tworzenie skomplikowanych systemów przetwarzaj¹cych wci¹¿ spotykamy
siê z jej rosn¹cym zastosowaniem w grach.
Historia informatyki od jej wczesnych pocz¹tków zwi¹zana by³a z grami komputerowymi. 
W roku 1952 Alexander Shafto Douglas opisa³ temat komunikacji cz³owiek-komputer w swojej pracy doktoranckiej, oraz stworzy³ program graj¹cy w popularne ``Kó³ko i Krzy¿yk''.
Do dziœ uznawany jest on za pierwsz¹ graficzn¹ grê komputerow¹.
\end{par}

\section{Podstawy algorytmów w grach.}
\begin{par}
Jednym z podstawowych przyk³adów zastosowania sztucznej inteligencji w grach komputerowych s¹ gry logiczne. 
Podstawowym algorytmem stosowanym w projektowaniu sztucznej inteligencji jest algorytm minmax.
Najprostszym przyk³adem jest gra ``Kó³ko i krzy¿yk'' gdzie przeszukiwane jest tzw. drzewo gry, kolejno sprawdzaj¹ce wszystkie mo¿liwe stany gry. 
W dowolnym momencie gry mo¿emy przeanalizowaæ wszystkie mo¿liwe posuniêcia ka¿dego z graczy, i d¹¿yæ do sytuacji gdzie mamy gwarantowany sukces.
Gra mo¿e zakoñczyæ siê remisem, zwyciêstwem gracza A, b¹dŸ zwyciêstwem gracza B.
Optymalizuj¹c decyzjê gracza A, musimy kolejno sprawdzaæ mo¿liwe posuniêcia na planszy i reakcje gracza B. 
Dla ka¿dego z mo¿liwych ruchów mo¿emy wówczas przeanalizowaæ optymaln¹ strategiê dla gracza B (poniewa¿ zak³adamy ¿e do takiej bêdzie on d¹¿y³) i staraæ siê znaleŸæ najlepsz¹ œcie¿kê która prowadzi do zwyciêstwa (b¹dŸ remisu) gracza A.
Nazwa wziê³a siê w³aœnie od minimalizowania strat, oraz maksymalizowania zysków podczas analizy œcie¿ek w drzewie.
£atwo zauwa¿yæ i¿ algorytm taki ma ogromn¹ z³o¿onoœæ dla rozbudowanych drzew, i jedynie dla ma³ych gier takich jak kó³ko i krzy¿yk daje wynik w realnym czasie.
Bez optymalizacji, oraz brania pod uwagê symetrii planszy, daje to drzewo wywo³añ sk³adaj¹ce siê 9! wêz³ów (³¹cznie z liœæmi). 
Oczywiœcie algorytm mo¿na zoptymalizowaæ chocia¿by poprzez programowanie dynamiczne, lecz dla gier bardziej z³o¿onych nie bêdziemy w stanie przeanalizowaæ wszystkich mo¿liwych sytuacji w grze w realnym czasie.
Przez lata szachy by³y jedn¹ z gier niemo¿liwych do rozwi¹zania za pomoc¹ powy¿szego podejœcia.
Nawet dziœ najlepsze programy szachowe nie graj¹ idealnie - nie analizuj¹ wszystkich mo¿liwych sytuacji w grze, a jedynie kilkadziesi¹t ruchów w przód.
Przy zastosowaniu optymalizacji oraz bazy danych zawieraj¹cej wiele strategii szachowych, wspó³czesne programy szachowe wygrywaj¹ z najlepszymi graczami.
Nieco inna sytuacja jest w grze GO, gdzie plansza rozmiaru 19x19 stanowi du¿e wyzwanie nawet dla wspó³czesnych superkomputerów. 
Do dziœ nie stworzono programu który wygrywa³by z profesjonalnymi zawodnikami GO.
Jak widaæ na Rys. \ref{fig:xo_tree}, pierwsze 2 poziomy drzewa gry Kó³ko i Krzy¿yk nie s¹ zbyt skomplikowane jeœli weŸmiemy pod uwagê symetriê.
Pocz¹tkowo z³o¿onoœæ drzewa roœnie wyk³adniczo, jednak mo¿liwoœci na planszy koñcz¹ siê zanim zaczyna to byæ problemem.
Inaczej wygl¹da³by przypadek drzewa gry GO (plansza rozmiaru 13x13), gdzie pierwszy ruch mo¿na wykonaæ na 28 unikalnych sposobów: Rys. \ref{fig:go_tree} przedstawia przyk³adowe pierwsze 28 wêz³ów drzewa gry GO (13x13), bior¹c pod uwagê symetriê planszy.
Sprawa komplikuje siê gdy rozpatrujemy wiêksze plansze.
Dla plansz o wymiarach 19x19 - standardowym rozmiarze obowi¹zuj¹cym na wszystkich turniejach gry GO - pierwszy ruch mo¿na wykonaæ na 55 sposobów (analogicznie do Rys.\ref{fig:go_tree}). Plansza GO ma 4 osie symetrii, mo¿e siê wówczas okazaæ ¿e odpowiedŸ przeciwnika bêdzie na tyle ``niesymetryczna'', ¿e ju¿ na drugim
poziomie drzewa musimy rozpatrzyæ wszystkie mo¿liwe pola na planszy, czyli 359 (19x19 - 2).

\begin{figure}[!h]
	\centering
	\includegraphics[width=5in]{obrazki/chess_tree.png}
	\caption{Schemat drzewa gry Kó³ko i Krzy¿yk.}
	\label{fig:xo_tree}
\end{figure}

\begin{figure}[!h]
	\centering
	\includegraphics[width=5in]{obrazki/go_tree.png}
	\caption{Przyk³ad pierwszych mo¿liwych unikalnych ruchów w grze GO.}
	\label{fig:go_tree}
\end{figure}

\end{par}
\begin{par}
Jeœli chcemy wprowadziæ podzia³ gier przydatny przy projektowaniu systemu pierwszym czynnikiem bêdzie typ rozgrywki ze wzglêdu na czas.
Wiêkszoœæ gier mo¿na podzieliæ wówczas w nastêpuj¹cy sposób:
\begin{itemize}
	\item Gry turowe - Gracze naprzemiennie wykonuj¹ ruchy, przy czym czas na podjêcie decyzji jest relatywnie du¿y - od kilku sekund nawet do 1-2 minut.
Wiele nieskomplikowanych gier turowych zosta³o ju¿ dawno rozwi¹zanych przez algorytmy typu minmax, do tego stopnia, ¿e systemy graj¹ w nie ju¿ niemal bezb³êdnie. 
W wielu przypadkach przestrzeñ rozwi¹zañ jest jednak wci¹¿ zbyt du¿a aby zrealizowaæ to algorytmem dok³adnym - przyk³adem mo¿e byæ wy¿ej wspomniana gra GO.
	\item Gry czasu rzeczywistego - Gra toczy siê w dynamicznym œrodowisku gry, czêsto z wieloma obiektami i graczami na raz. Czêsto czas na podjêcie optymalnej decyzji przez algorytm jest mocno ograniczony - program musi podejmowaæ decyzje nawet do 30 razy w ci¹gu sekundy. Oprócz tego próba dyskretyzacji œrodowiska i znalezienia dok³adnego rozwi¹zania z przestrzeni stanów gry jest w praktyce niewykonalna. Przyk³adem mog¹ byæ tutaj ró¿nego rodzaju dwuwymiarowe lub trójwymiarowe gry akcji, które czêsto posiadaj¹ z³o¿one œrodowiska gry, wiele dynamicznych obiektów oraz graczy uczestnicz¹cych w rozgrywce poprzez przez sieæ komputerow¹. Przy projektowaniu sztucznej inteligencji w takim œrodowisku w tej chwili mo¿emy liczyæ jedynie na wyniki przybli¿one.
\end{itemize}
\end{par}
\begin{par}
Sztuczna inteligencja w grach mo¿e dotyczyæ ró¿nych aspektów gry. 
W grach logicznych (turowych) g³ównym, i jedynym problemem jest podjêcie najlepszej decyzji dla aktualnego stanu gry daj¹cej zwyciêstwo. 
W wiêkszoœci gier logicznych sztuczna inteligencja ma za zadanie symulacjê godnego przeciwnika dla cz³owieka.
Czêsto jednak te same algorytmy mog¹ s³u¿yæ do celów edukacyjnych b¹dŸ do podpowiedzi - ten sam system graj¹cy w szachy mo¿e graæ przeciwko nam, jak i podpowiadaæ nam ruchy na podstawie naszej pozycji na planszy.
Podobnie wygl¹da sytuacja w grach czasu rzeczywistego, jednak problem znacznie siê komplikuje.
Poniewa¿ przestrzeñ rozwi¹zañ jest bardzo du¿a, czêsto podjêcie decyzji mo¿e byæ wspomagane przez algorytm przybli¿ony, b¹dŸ oparty na algorytmach genetycznych.
Algorytm minmax w wiêkszoœci przypadków zawodzi, b¹dŸ jego czas dzia³ania jest zbyt wolny do zastosowania w dynamicznie dzia³aj¹cym œrodowisku.
Korzystaj¹c z algorytmów ``jedynie'' optymalizuj¹cych rozgrywkê tracimy mo¿liwoœæ rozegrania idealnej partii gry, jednak czêsto wystarcza to dla stworzenia godnego przeciwnika dla ludzkich graczy.
\end{par}

\section{Podstawy algorytmów genetycznych.}
\begin{par}
Czêsto wykorzystywanym sposobem rozwi¹zania z³o¿onego problemu algorytmicznego s¹ algorytmy genetyczne.
Opieraj¹ siê one na zasadach ewolucji odkrytych przez Charlesa Darwina, i wzoruj¹ siê na faktycznych rozwi¹zaniach doboru naturalnego wystêpuj¹cych w przyrodzie.
Algorytm ewolucyjny opiera siê na wprowadzeniu losowego czynnika do ca³ej procedury, i tym te¿ ró¿ni siê od klasycznego algorytmu, i¿ jest niedeterministyczny. 
Ogólny przebieg algorytmu genetycznego mo¿e wygl¹daæ nastêpuj¹co:
\begin{enumerate}
\item Wygenerowanie pocz¹tkowej populacji osobników (propozycji rozwi¹zañ) w sposób losowy.
\item Przeliczenie funkcji przystosowania dla ka¿dego z osobników.
\item Uporz¹dkowanie populacji malej¹co wzglêdem wyniku funkcji przystosowania.
\item Wybranie populacji rodzicielskiej zgodnie z przyjêt¹ metod¹ selekcji.
\item Krzy¿owanie osobników z populacji rodzicielskiej i otrzymanie nowej populacji - nowe potomstwo posiada cechy rodziców którzy w poprzedniej populacji byli najlepiej przystosowani do rozwi¹zania danego problemu.
\item Mutacja czêœci potomstwa - wprowadzenie czynnika losowego poprzez zmianê niektórych fragmentów chromosomu w sposób losowy.
\item Jeœli warunek koñcowy nie zosta³ osi¹gniêty powrót do kroku 2, w przeciwnym wypadku koniec algorytmu.
\end{enumerate}
Wynikiem takiego algorytmu jest nie jedno rozwi¹zanie problemu, a ca³a ich populacja.
W wiêkszoœci algorytmów genetycznych mo¿na wydzieliæ kilka koniecznych do zaprojektowania klas b¹dŸ procedur.
\begin{enumerate}
\item Chromosom oraz Populacja
	\begin{par}
		Pierwszym krokiem jest zdefiniowanie typu danych odpowiednich do przetrzymywania informacji o danym osobniku.
		Odpowiednio zaprojektowany format danych (zwany Chromosomem) pozwoli na ³atw¹ implementacjê pozosta³ych elementów oraz zapewni generowanie optymalnych wyników.
		Informacja ta czêsto jest reprezentowana przez tablicê wartoœci, b¹dŸ listê cech przypisanych do danej klasy. 
		Chromosom odpowiada za informacjê o pojedynczym osobniku, natomiast Populacja traktowana jest jako wszystkie osobniki nale¿¹ce do danego zbioru w danej iteracji algorytmu. 
		O ile w podstawowych algorytmach genetycznych Populacja jest jedynie kontenerem, dobrze jest pamiêtaæ o ewentualnym rozbudowaniu Populacji do bardziej z³o¿onej klasy, dziêki czemu bêdziemy mieli mo¿liwoœæ prostego porównywania, b¹dŸ zapamiêtywania ca³ych populacji.
	\end{par}
\item Funkcja Przystosowania
	\begin{par}
		Kolejnym istotnym krokiem jest zdefiniowanie funkcji przystosowania.
		W doborze naturalnym wystêpuj¹cym w przyrodzie, osobniki danego gatunku roœliny b¹dŸ zwierzêcia ró¿ni¹ siê pod wzglêdem genetycznym. 
		Mo¿na wówczas wywnioskowaæ i¿ czêœæ z nich jest lepiej przystosowana do danego œrodowiska, co z kolei wp³ywa na ich szanse prze¿ycia w trudnych sytuacjach, licznoœæ potomstwa, d³ugoœæ ¿ycia.
		Poniewa¿ potomstwo dziedziczy geny po swoich rodzicach, ``zwyciêskie'' cechy w kolejnym pokoleniu s¹ bardziej powszechne.
		Odpowiednikiem funkcji przystosowania jest w³aœnie wynikowa cech danego osobnika która okreœla prawdopodobieñstwo przekazania jego genów w kolejnym pokoleniu.
		Funkcja przystosowania jest doœæ prosta w realizacji, o ile dane dotycz¹ce osobnika s¹ ³atwe do zmierzenia -- wówczas mo¿e byæ to jedynie kwestia policzenia wartoœci funkcji liniowej z odpowiednimi wagami, gdzie argumentami s¹ wyniki osobnika podczas symulacji w œrodowisku.
		Mimo to w wiêkszoœci algorytmów genetycznych dobranie odpowiednich wag w funkcji przystosowania jest kluczowym czynnikiem nad którym póŸniej mo¿na d³ugo pracowaæ przy optymalizacji algorytmu.
	\end{par}
\item Krzy¿owanie
	\begin{par}
		Po ka¿dym kroku algorytmu zazwyczaj mo¿emy uporz¹dkowaæ osobniki nale¿¹ce do bie¿¹cej populacji i wylosowaæ z niej pewien zbiór osobników najlepiej przystosowanych (wp³yw na to wynik funkcji przystosowania). 
		Wówczas dokonujemy krzy¿owania pomiêdzy nimi, dziêki czemu otrzymujemy osobniki nowe, jednak posiadaj¹ce pewne cechy swoich ``rodziców''.
		Krok ten jest kluczowy jeœli chcemy osi¹gaæ coraz lepsze wyniki w kolejnych populacjach, poniewa¿ od dobrej metody krzy¿owania zale¿y czy kolejne populacje bêd¹ lepiej przystosowane do rozwi¹zania problemu.
		Z³e zaprojektowanie krzy¿owania jest jednym z czêstszych powodów osi¹gania przez populacjê z³ych wyników, zw³aszcza gdy Chromosom ma z³o¿on¹ strukturê.
		Samo krzy¿owanie czêsto równie¿ posiada czynnik losowy (w klasycznych przyk³adach dotycz¹cych krzy¿owania siê dwóch ci¹gów bitowych, losowany jest punkt ³¹czenia siê dwóch ci¹gów).
	\end{par}
\item Mutacja
	\begin{par}
		O ile pocz¹tkowa losowoœæ algorytmu polegaj¹ca na wylosowaniu pierwszej populacji jest szybko zastêpowana przez populacjê osi¹gaj¹c¹ lepsze wyniki, 
		warto w trakcie ca³ego procesu próbowaæ modyfikowaæ kilka osobników, nawet jeœli mog³oby to spowodowaæ chwilowe pogorszenie populacji. 
		W innym przypadku zbyt uporz¹dkowana procedura selekcji i krzy¿owania osobników spowoduje stagnacjê populacji.
		Czêsto mo¿na to zauwa¿yæ gdy po kilku iteracjach wiêkszoœæ, b¹dŸ ca³a populacja jest identyczna.
		Najczêstsz¹ realizacj¹ mutacji jest zmiana jakiegoœ parametru (b¹dŸ grupy parametrów) danego osobnika na wartoœæ zupe³nie losow¹.
		Poniewa¿ w du¿ej mierze zale¿y to od budowy Chromosomu, nie ma uniwersalnej metody na zaimplementowanie mutacji.
		Najczêœciej mutacja wystêpuje z niskim prawdopodobieñstwem,
		\begin{center}
			$p_m < 0.1$
		\end{center}
		tak aby nie ingerowaæ zbyt mocno w algorytm. Ostatecznie nale¿y d¹¿yæ do pewnej systematycznej optymalizacji, a nie tylko polegaæ na czynniku losowym.
	\end{par}
\item Metoda Selekcji
	\begin{par}
		Sama metoda wyboru populacji rodzicielskiej równie¿ ma znaczenie, poniewa¿ jednak jest ona oparta na wartoœci funkcji przystosowania, to ju¿ sama metoda wyboru ma mniej krytyczne znaczenie.
		Najbardziej popularne metody selekcji to:
		\begin{enumerate}
			\item Metoda ko³a ruletki.
				\begin{par}
					Sama nazwa bierze siê od popularnej gry w ruletkê, w której pole powierzchni ka¿dego wycinka ko³a jest proporcjonalne do prawdopodobieñstwa wylosowania danej liczby. 
					Oczywiœcie w klasycznej ruletce pola wycinków ko³a s¹ równe, zatem szansa wylosowania ka¿dej liczby jest taka sama.
					W samym algorytmie wirtualne ``wycinki ko³a'' nie musz¹ oczywiœcie byæ równe. 
					Osobnik który osi¹ga lepsze wyniki w funkcji przystosowania otrzymuje wiêksze prawdopodobieñstwo w³¹czenia do populacji rodzicielskiej ni¿ osobniki s³absze. 
					Aby to zrealizowaæ losowana jest pewna wartoœæ (najczêœciej z przedzia³u [0,1], liczb wymiernych) która potem jednoznacznie okreœla który osobnik zosta³ wylosowany.
					Praktycznie realizowane jest to w nastêpuj¹cy sposób:
					\begin{center}
						$p(k)=\frac{f(k)}{\displaystyle\sum\limits_{i=0}^n f(i)}$
					\end{center}
					gdzie $p(k)$ oznacza prawdopodobieñstwo wylosowana k-tego osobnika z populacji, a $f(i)$ wartoœæ funkcji przystosowania i-tego osobnika. Poniewa¿ wartoœci s¹ znormalizowane, suma prawdopodobieñstw wylosowania ka¿dego z osobników jest równa 1.
					Po uporz¹dkowaniu osobników, potrzebna jest jedynie losowa wartoœæ ktora jednoznacznie okreœli wybór osobnika.
					
				\end{par}
			\item Metoda rankingowa.
				\begin{par}
					W tej metodzie sortujemy osobniki malej¹co wzglêdem funkcji przystosowania i wybieramy populacjê rodziców jako $m$ pierwszych osobników (zwan¹ czêsto elit¹ populacji). 
					Ma to pewn¹ wadê, gdy¿ powoduje po pewnym czasie stagnacjê (brak czynnika losowego). 
					Innym wariantem jest selekcja turniejowa w której najpierw dzielimy grupê na $G$ podgrup spoœród których wybieramy najlepsze osobniki do populacji rodzicielskiej. 
					Otrzymujemy w ten sposób G rodziców, wœród których niekoniecznie s¹ najlepsze osobniki globalnie (nawet z bardzo silnej grupy przechodzi tylko jeden osobnik). 
					Daje nam to ju¿ pewn¹ losowoœæ w wyborze populacji rodzicielskiej.
				\end{par}
			\item Po³¹czenie kilku metod.
				\begin{par}
					Dodatkowym elementem mo¿e byæ po³¹czenie kilku metod selekcji celem otrzymania najbardziej optymalnej selekcji dla danego problemu genetycznego. 
					W zasadzie bardziej z³o¿one problemy ewolucyjne wrêcz wymagaj¹ w³asnej inwencji do zaprojektowania dobrego systemu.
				\end{par}
		\end{enumerate}
	\end{par}
\end{enumerate}
	Du¿¹ czêœci¹ dobrego systemu genetycznego jest odpowiednia mo¿liwoœæ konfiguracji danych odpowiadaj¹cych za ka¿dy z kroków.
	Mamy dziêki temu mo¿liwoœæ przetestowania ró¿nych podejœæ do danego problemu bez bezpoœrednich i czêsto uci¹¿liwych zmian w kodzie programu.
	Oprócz tego ca³y proces mo¿na zautomatyzowaæ, dziêki czemu mo¿emy w prosty sposób przetestowaæ algorytm dla ró¿nych danych konfiguracyjnych.
\end{par}
